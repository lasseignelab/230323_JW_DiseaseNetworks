---
title: "01_tissue_specific_edge_identification"
author: "Jordan Whitlock"
date: '2023-08-01'
output: html_document
---
Purpose: Identify Tissue-specific edges in SEP1 communities 
1. Combine all edges for all tissues into a single dataframe
2. Calculate specificity and multiplcity for edges of SETBP1
3. Define tissue-specific edges
4. Subset the SETBP1 tissue-specific edges for those in SETP1 communities (identified with condor)
5. Find the overlap of those edges in affected tissues that have a multiplicity value <= Q1

```{r load-libraries}
set.seed(2178)
library(here)
library(tidyr)
library(stringr)
library(lintr)
library(UpSetR)
library(ComplexHeatmap)
library(ggplot2)
library(styler)
library(dplyr)
library(reshape2)
ptm <- proc.time()
```

```{r}
# affected tissues
affected <- c(
  "BLOOD",
  "BRAIN",
  "HEART",
  "KIDNEY",
  "BLADDER",
  "LUNG",
  "MUSCLE",
  "SMALL_INTESTINE",
  "STOMACH",
  "ESOPHAGUS",
  "BONE_MARROW"
)
```

```{r loading-geneset}
# load in gene set for SETBP1 (converted by LW)
setbp1_genes <- read.csv(here("data/SETBP1_Targets/setbp1_targets_geneconversions.csv"))
setbp1_genes <- setbp1_genes$name %>% as.vector()
```


# generating edges from the regNet
```{r}
files <- list.files(here("results/PANDA"), full.names = TRUE)

names <- sub("expression_PANDA.Rdata", "", basename(files)) %>%
  sub("gtex_", "", .) %>%
  sub("_PANDA.Rdata", "", .)

regNet_edges <- list()

for (i in files) {
  # load in the pandaResults
  load(i)
  # extracting-networks
  regNet <- pandaResults@regNet
  regNet <- reshape2::melt(regNet,
    varnames = c("TF", "gene"),
    value.name = "edge_weight"
  )

  # filter for TF SETBP1
  regNet <- regNet[regNet$TF == "SETBP1", ]

  # creating edges
  regNet$edges <- paste(regNet$TF, regNet$gene, sep = "_")
  regNet <- subset(regNet, select = -c(TF, gene))

  # store in list
  regNet_edges[[i]] <- regNet

  # print
  print(paste0(i, "melted and edges created"))
}

names(regNet_edges) <- names

save(regNet_edges,
  file = here("results/tissue_specific_edges/edges_list_object.Rdata")
)
```

# combine all regNets for all tissues 
```{r}
merged_df <- regNet_edges[[1]]
for (i in 2:length(regNet_edges)) {
  merged_df <- left_join(merged_df, regNet_edges[[i]], by = "edges")
}

# reorder the columns
merged_df <- merged_df %>%
  select(edges, edge_weight, everything())

# rename the columns
names(merged_df)[-1] <- names(regNet_edges)

# save the object
save(merged_df,
  file = here("results/tissue_specific_edges/merged_edges_object.Rdata")
)
```

We wanted to identify tissue-specific edges as previously defined in [Sonawane et al Cell Reports 2017](https://www.cell.com/cell-reports/fulltext/S2211-1247(17)31418-3#secsectitle0080); formulas 1, 2 & 3 to calculate tissue-specific-edges
```{r}
# ln(e^x + 1) transform edge weights to address negatives
merged_df <- merged_df %>% mutate(across(-1, ~ log(exp(.) + 1)))

save(merged_df,
  file = here("results/tissue_specific_edges/merged_edges_transformed.Rdata")
)

# make df for storing median and iqr
med_iqr_df <- data.frame(edges = merged_df$edges)

# calculate median and IQR for each edge (row) across all tissues
med_iqr_df$median_all <- apply(merged_df[, -1], 1, median) # median for each row
med_iqr_df$IQR_all <- apply(merged_df[, -1], 1, IQR) # IQR for each row

save(med_iqr_df, file = here("results/tissue_specific_edges/med_iqr_df.Rdata"))

# compare edge weights across tissues using Sonawane et al Equation 2 to calculate specificity scores
merged_df[, -1] <- t(apply(
  merged_df[, -1], 1,
  function(x) (x - med_iqr_df$median_all) / med_iqr_df$IQR_all
)) # transpose because apply returns rows as tissues and columns as edges

# calculate multiplicity
merged_df$multiplicity <- apply(merged_df[-1], 1, function(x) sum(x > 2))
hist(merged_df$multiplicity) # visualize

multiplicity <- merged_df[, c(1, 33)]

save(merged_df,
  file = here("results/tissue_specific_edges/specificity_multiplicity.Rdata")
)

multiplicity <- multiplicity %>%
  separate(edges, into = c("TF", "gene"), sep = "_", remove = FALSE) # split edges

save(multiplicity,
  file = here("results/tissue_specific_edges/multiplicity.Rdata")
)
```

# define tissue specific edges as those with a specificity scores > 2
```{r}
merged_df <- merged_df[, -33]
merged_df[, -1] <- lapply(merged_df[, -1], function(x) ifelse(x > 2, 1, 0))

# melt tissue-specific edges and grab only those that are tissue-specific
tissue_specific <- melt(merged_df,
  id.vars = "edges",
  variable.name = "Tissue",
  value.name = "Tissue Specific"
)
tissue_specific <- tissue_specific[tissue_specific$`Tissue Specific` == 1, ]

# split edges
tissue_specific <- tissue_specific %>%
  separate(edges, into = c("TF", "gene"), sep = "_", remove = FALSE)

save(tissue_specific, file = here("results/tissue_specific_edges/tissue_specific_edges.Rdata"))
```

## Cross reference tissue-specific edges with the CONDOR communitites for SETBP1
```{r}
load(here("results/condor/condor_list.Rdata"))
setbp1_comm_number <- read.csv(here("results/condor/communitynumber_setbp1_TF.csv"))
```

```{r comm-members-tse-edges}
# grab nodes interacting with SETBP1 from tse
tse_genes <- as.vector(unique(tissue_specific$gene))

# Subset each dataframe for tse genes in the list and annotate with the list name
subset_dfs <- lapply(names(condor_list), function(list_name) {
  df <- condor_list[[list_name]]
  subset_df <- df[df$name %in% tse_genes, ]
  subset_df$tissue_type <- list_name
  return(subset_df)
})

# Bind all subset dataframes into a single dataframe
tse_edges <- bind_rows(subset_dfs)

# filter communities for communities known to contain SETBP1 for each tissue
setbp1_comms <- paste(setbp1_comm_number$tissue_type,
  setbp1_comm_number$com_value,
  sep = "_"
) # generate SETBP1 community vector label
tse_edges$annotation <- paste(tse_edges$tissue_type,
  tse_edges$condor_memb,
  sep = "_"
) # generate annotation to filter tse edges for setbp1_comms with
data <- tse_edges[tse_edges$annotation %in% setbp1_comms, ] # filter for only setbp1 communities
data <- data[data$name %in% setbp1_genes, ] # filter for known targets of SETBP1
```

```{r assign-mult-to-ts-setbp1-comm-edges}
mult_genes <- multiplicity[!grepl("-", multiplicity$gene), ] # remove genes with alternate alleles aka a "-"
mult_genes <- mult_genes %>% separate(edges, c("tf", "gene")) # grab multiplicity

merged_data <- left_join(data, mult_genes, by = c("name" = "gene")) # add multiplicity to tse community data

merged_data_gene <- merged_data[merged_data$entity == "gene", ] %>% na.omit(.) # filter for only genes

affected_merged <- merged_data_gene[merged_data_gene$tissue_type %in% affected, ] # filter for affected tissues
```

```{r visualize-tse-in-setbp1-comm-mult}
# number of tse per tissue
affected_merged$tissue_type <- str_to_title(affected_merged$tissue) %>% gsub("_", " ", .)

# assign multiplicity groupings
affected_merged <- affected_merged %>%
  mutate(multiplicity_group = case_when(
    multiplicity == 1 ~ "1",
    multiplicity == 2 ~ "2",
    multiplicity == 3 ~ "3",
    multiplicity == 4 ~ "4",
    multiplicity >= 5 ~ "5+"
  ))

# reorder and plot
png(
  filename = here("results/tissue_specific_edges/tse_tissues_plot.png"),
  width = 3000,
  height = 2000,
  res = 300
)
ggplot(affected_merged, aes(x = tissue_type, fill = multiplicity_group)) +
  geom_bar(position = "stack") +
  theme_bw() +
  labs(x = "Tissue Type", y = "Frequency") +
  scale_fill_manual(
    values = c("#2C1D6C", "#533180", "#A468A9", "#D3B1C5"),
    labels = c("1", "2", "4", "5+"), # note: there was no 3 in this data
    name = "Multiplicity Group"
  ) +
  theme(text = element_text(family = "Helvetica")) +
  theme(axis.text.x = element_text(color = "black", angle = 45, vjust = 0.6)) +
  theme(axis.text.y = element_text(color = "black")) +
  theme(axis.text = element_text(face = "bold")) +
  theme(legend.title = element_text(face = "bold")) +
  theme(legend.text = element_text(face = "bold")) +
  theme(axis.title.y = element_text(face = "bold")) +
  theme(axis.title.x = element_text(face = "bold")) +
  labs(
    x = "GTEx Affected Tissues",
    y = "Number of SETBP1's Tissue-specific Edges \n in SETBP1 Communities"
  ) +
  theme(
    title = element_text(face = "bold"),
    plot.title = element_text(hjust = 0, size = 20),
    axis.title.x = element_text(size = 16),
    axis.title.y = element_text(size = 16),
    axis.text.x = element_text(size = 16),
    axis.text.y = element_text(size = 16)
  )
dev.off()
```


NOTE FOR CR: Need docker version sebtp1_manuscript:1.0.12
Code below for UpSet plot was adapted from vignette [here](https://jokergoo.github.io/ComplexHeatmap-reference/book/upset-plot.html) 
```{r uset-plot-overlapping-edges}
# identifying quartiles for multiplcity
summary(affected_merged$multiplicity)
# Min. 1st Qu.  Median    Mean 3rd Qu.    Max.
#   1.00   25.00   30.00   25.79   31.00   31.00

# filtering to excude edges that have a multiplicity of less than or equal to Q1
affected_merged <- affected_merged[affected_merged$multiplicity <= 25, ]

# formatting data
subset <- subset(affected_merged, select = c("name", "tissue_type")) # selecting columns of interest

subset$present <- 1 # adding a count for sets
subset <- pivot_wider(subset, names_from = name, values_from = present) # pivoting wider
subset <- mutate_all(subset, ~ replace_na(., 0)) # change NA to 0
subset$tissue_type <- str_to_title(subset$tissue_type) %>% gsub("_", " ", .) # reformat tissue type
row_names_data <- subset$tissue_type
subset <- subset[, -1]
rownames(subset) <- row_names_data

m1 <- make_comb_mat(subset, mode = "distinct") # distinct mode: 1 means in that set and 0 means not in that set, then 1 1 0
t(m1) # view
colnames(m1) <- c(
  "Bone Marrow",
  "Brain",
  "Espohagus",
  "Stomach",
  "Heart",
  "Lung",
  "Bladder",
  "Blood",
  "Small Intestine",
  "Muscle",
  "Kidney"
) # add tissues

# annotating tissues

# plotting upset plot
png(
  filename = here("results/tissue_specific_edges/upset_plot.png"),
  width = 3000,
  height = 2000,
  res = 300
)
UpSet(m1,
  left_annotation = upset_left_annotation(m1,
    ylim = c(0, 30),
    gp = gpar(fill = "#2C1D6C")
  ),
  comb_col = "#2C1D6C",
  bg_pt_col = "#E2D7DB",
  bg_col = "#EEE5E8"
)
dev.off()
```

```{r}
# run style
style_file(here("src/tissue_specific_edges/01_tissue_specific_edge_identification.Rmd"))
# lintr was run as well
```

```{r}
fptm <- proc.time() - ptm
fptm[3] / 60
```
elapsed 
79.43523 

```{r}
sessionInfo()
```
R version 4.1.3 (2022-03-10)
Platform: x86_64-pc-linux-gnu (64-bit)
Running under: Ubuntu 20.04.6 LTS

Matrix products: default
BLAS/LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.8.so

locale:
[1] C

attached base packages:
[1] grid      stats     graphics  grDevices utils     datasets  methods   base     

other attached packages:
 [1] reshape2_1.4.4        dplyr_1.1.0           styler_1.9.0          ggplot2_3.4.1         ComplexHeatmap_2.10.0 UpSetR_1.4.0          lintr_3.0.2          
 [8] stringr_1.5.0         tidyr_1.3.0           here_1.0.1            pandaR_1.26.0         Biobase_2.54.0        BiocGenerics_0.40.0  

loaded via a namespace (and not attached):
 [1] Rcpp_1.0.10         lattice_0.20-45     circlize_0.4.15     png_0.1-8           ps_1.7.2            rprojroot_2.0.3     digest_0.6.31      
 [8] foreach_1.5.2       utf8_1.2.3          R6_2.5.1            plyr_1.8.8          stats4_4.1.3        pillar_1.8.1        GlobalOptions_0.1.2
[15] rlang_1.0.6         lazyeval_0.2.2      rstudioapi_0.14     callr_3.7.3         hexbin_1.28.2       R.utils_2.12.2      R.oo_1.25.0        
[22] S4Vectors_0.32.4    GetoptLong_1.0.5    RUnit_0.4.32        desc_1.4.2          igraph_1.4.1        munsell_0.5.0       compiler_4.1.3     
[29] xfun_0.37           pkgconfig_2.0.3     shape_1.4.6         tidyselect_1.2.0    tibble_3.1.8        gridExtra_2.3       IRanges_2.28.0     
[36] codetools_0.2-18    matrixStats_0.63.0  reshape_0.8.9       fansi_1.0.4         crayon_1.5.2        withr_2.5.0         R.methodsS3_1.8.2  
[43] gtable_0.3.1        lifecycle_1.0.3     magrittr_2.0.3      scales_1.2.1        cli_3.6.0           stringi_1.7.12      remotes_2.4.2      
[50] rex_1.2.1           doParallel_1.0.17   xml2_1.3.3          generics_0.1.3      vctrs_0.5.2         cyclocomp_1.1.0     rjson_0.2.21       
[57] RColorBrewer_1.1-3  iterators_1.0.14    tools_4.1.3         R.cache_0.16.0      glue_1.6.2          purrr_1.0.1         processx_3.8.0     
[64] parallel_4.1.3      clue_0.3-64         colorspace_2.1-0    cluster_2.1.2       knitr_1.42         
